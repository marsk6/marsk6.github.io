<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link href="/favicon/favicon.ico" rel="icon" sizes="16x16" type="image/png"/><meta name="google-site-verification" content="gbcmtOy1jGMqGfsCVG7j8aenAp_gydeXbbu8n0Iy0zQ"/><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/201eac2cb8c21791.css" as="style"/><link rel="stylesheet" href="/_next/static/css/201eac2cb8c21791.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-4917d180073dfd70.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-c637f382bbf38b66.js" defer=""></script><script src="/_next/static/chunks/pages/_app-bda23c1bd476989b.js" defer=""></script><script src="/_next/static/chunks/962-3f8719fde5a7012d.js" defer=""></script><script src="/_next/static/chunks/842-58fb248c666522ec.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-09f620f52e4ad90b.js" defer=""></script><script src="/_next/static/TD84s2Xo2UN8FejtQxb1E/_buildManifest.js" defer=""></script><script src="/_next/static/TD84s2Xo2UN8FejtQxb1E/_ssgManifest.js" defer=""></script></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-MNH8X63" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div id="__next"><section class="flex flex-col max-w-full bg-stone-50 dark:bg-stone-900 text-stone-800 dark:text-[#c9d1d9]"><span class="pointer-events-none fixed inset-0 h-full w-full opacity-100"><svg class="pointer-events-none h-full w-full touch-none select-none bg-transparent" version="1.1" xmlns="http://www.w3.org/2000/svg" fill="transparent"><defs><pattern id="grid-0" width="640" height="640" patternUnits="userSpaceOnUse" fill="transparent" class="bg-transparent"><circle cx="640" cy="640" r="2" opacity="1" class="bg-transparent fill-stone-300 dark:fill-stone-700"></circle></pattern><pattern id="grid-1" width="160" height="160" patternUnits="userSpaceOnUse" fill="transparent" class="bg-transparent"><circle cx="160" cy="160" r="2" opacity="1" class="bg-transparent fill-stone-300 dark:fill-stone-700"></circle></pattern><pattern id="grid-2" width="40" height="40" patternUnits="userSpaceOnUse" fill="transparent" class="bg-transparent"><circle cx="40" cy="40" r="2" opacity="1" class="bg-transparent fill-stone-300 dark:fill-stone-700"></circle></pattern><pattern id="grid-3" width="10" height="10" patternUnits="userSpaceOnUse" fill="transparent" class="bg-transparent"><circle cx="10" cy="10" r="2" opacity="0.16666666666666669" class="bg-transparent fill-stone-300 dark:fill-stone-700"></circle></pattern></defs><rect width="100%" height="100%" fill="url(#grid-0)"></rect><rect width="100%" height="100%" fill="url(#grid-1)"></rect><rect width="100%" height="100%" fill="url(#grid-2)"></rect><rect width="100%" height="100%" fill="url(#grid-3)"></rect></svg></span><header class="p-3 sticky z-[9999] shadow-[0px_0px_20px_0px_#e2e8f0] bg-white dark:shadow-stone-800 dark:bg-[#19191c] lg:top-0"><section class="flex flex-shrink-0 items-center lg:max-w-5xl lg:mx-auto"><a class="font-medium text-xl cursor-pointer flex mr-auto items-center text-2xl" href="/"><span class="bg-clip-text bg-gradient-to-r from-stone-500 to-stone-800 text-transparent dark:from-stone-500 dark:to-stone-200 ">Hea</span>✨</a><nav class="flex flex-col gap-2"><a class="relative flex items-center gap-2 px-4 font-semibold text-slate-700 dark:text-slate-200 hover:after:absolute hover:after:h-0.5 hover:after:bg-stone-400 hover:after:w-4/5 hover:after:-bottom-2" href="/lab"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-brand-react"><path d="M6.306 8.711c-2.602 .723 -4.306 1.926 -4.306 3.289c0 2.21 4.477 4 10 4c.773 0 1.526 -.035 2.248 -.102"></path><path d="M17.692 15.289c2.603 -.722 4.308 -1.926 4.308 -3.289c0 -2.21 -4.477 -4 -10 -4c-.773 0 -1.526 .035 -2.25 .102"></path><path d="M6.305 15.287c-.676 2.615 -.485 4.693 .695 5.373c1.913 1.105 5.703 -1.877 8.464 -6.66c.387 -.67 .733 -1.339 1.036 -2"></path><path d="M17.694 8.716c.677 -2.616 .487 -4.696 -.694 -5.376c-1.913 -1.105 -5.703 1.877 -8.464 6.66c-.387 .67 -.733 1.34 -1.037 2"></path><path d="M12 5.424c-1.925 -1.892 -3.82 -2.766 -5 -2.084c-1.913 1.104 -1.226 5.877 1.536 10.66c.386 .67 .793 1.304 1.212 1.896"></path><path d="M12 18.574c1.926 1.893 3.821 2.768 5 2.086c1.913 -1.104 1.226 -5.877 -1.536 -10.66c-.375 -.65 -.78 -1.283 -1.212 -1.897"></path><path d="M11.5 12.866a1 1 0 1 0 1 -1.732a1 1 0 0 0 -1 1.732z"></path></svg>实验室</a></nav><div class="cursor-pointer px-4 flex items-center gap-2"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-sun"><path d="M12 12m-4 0a4 4 0 1 0 8 0a4 4 0 1 0 -8 0"></path><path d="M3 12h1m8 -9v1m8 8h1m-9 8v1m-6.4 -15.4l.7 .7m12.1 -.7l-.7 .7m0 11.4l.7 .7m-12.1 -.7l-.7 .7"></path></svg></div></section></header><section class="container flex gap-2 relative flex-col lg:max-w-5xl lg:flex-row lg:mt-4 lg:items-start lg:mx-auto"><section class="p-6 bg-[#fefefe] dark:bg-[#19191c] opacity-100 rounded shadow-[0px_0px_20px_0px_#e2e8f0] dark:shadow-stone-800 order-3 lg:order-2 lg:w-[calc(100%-44rem)] lg:p-8 css-kk9mc1"><article class="p-2"><header class="mb-4"><h1 class="text-center font-medium lg:text-4xl text-3xl">译 - JavaScript 引擎底层：Shapes 和 Inline Caches</h1><div class="mt-2 flex justify-center text-xs items-center gap-4"><div class="flex gap-0.5 items-center"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-calendar"><path d="M4 5m0 2a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v12a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2z"></path><path d="M16 3l0 4"></path><path d="M8 3l0 4"></path><path d="M4 11l16 0"></path><path d="M11 15l1 0"></path><path d="M12 15l0 3"></path></svg><span>发布于 2022-10-18</span></div><div class="flex gap-0.5 items-center"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-clock"><path d="M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0"></path><path d="M12 7l0 5l3 3"></path></svg><span>约 <!-- -->18<!-- --> 分钟</span></div></div></header><section class="markdown-body max-w-none dark:bg-[#19191c]"><blockquote>
<p>原文 <a href="https://mathiasbynens.be/notes/shapes-ics" target="_blank" rel="nofollow">JavaScript engine fundamentals: Shapes and Inline Caches · Mathias Bynens</a></p>
</blockquote>
<p>本文描述了所有 JavaScript 引擎共有的一些关键基础知识——而不仅是 V8。作为 JavaScript 开发人员，深入了解 JavaScript 引擎的工作原理可以帮你了解代码的性能点。</p>
<h2 id="javascript-引擎编译流程"><a aria-hidden="true" tabindex="-1" href="#javascript-引擎编译流程"><span class="icon icon-link"></span></a>JavaScript 引擎编译流程</h2>
<p>从你编写的 JavaScript 代码开始，JavaScript 引擎解析源代码并将其转换为抽象语法树 (AST)，之后解释器基于 AST 生成字节码。</p>
<figure class="rehype-figure"><img src="https://cdn.jsdelivr.net/gh/marsk6/image-center@master/parse-js.png" alt="parse-js" loading="lazy"/><figcaption>parse-js</figcaption></figure>
<p>为了使其运行得更快，会把生成的字节码与编译分析数据一起发送到优化编译器。优化编译器根据编译分析数据做出某些假设，然后生成高度优化的机器代码。如果某些假设被证明是不对的，则优化编译器会取消优化并返回给解释器。</p>
<h3 id="解释器编译器的工作流程"><a aria-hidden="true" tabindex="-1" href="#解释器编译器的工作流程"><span class="icon icon-link"></span></a>解释器/编译器的工作流程</h3>
<p>现在，让我们分析这个流程中实际运行 JavaScript 代码的部分，即代码被解释和优化的部分，并回顾一下主要 JavaScript 引擎之间的一些差异。</p>
<p>通常，有一个包含解释器和优化编译器的流程。解释器快速生成未优化的字节码，优化编译器需要更长的时间，但最终生成高度优化的机器码。</p>
<figure class="rehype-figure"><img src="https://cdn.jsdelivr.net/gh/marsk6/image-center@master/parse-js-2.png" alt="parse-js-2" loading="lazy"/><figcaption>parse-js-2</figcaption></figure>
<p>这个流程基本就是 V8 的工作方式</p>
<figure class="rehype-figure"><img src="https://cdn.jsdelivr.net/gh/marsk6/image-center@master/parse-js-v8.png" alt="parse-js-v8" loading="lazy"/><figcaption>parse-js-v8</figcaption></figure>
<p>V8 中的解释器称为 Ignition，负责生成和执行字节码。当它运行字节码时，它会收集分析数据，例如经常调用的函数，这些数据可用于加快以后的执行速度。生成的字节码和分析数据被传递给我们的优化编译器 TurboFan，根据分析数据生成高度优化的机器代码。</p>
<figure class="rehype-figure"><img src="https://cdn.jsdelivr.net/gh/marsk6/image-center@master/parse-js-SpiderMonkey.png" alt="parse-js-SpiderMonkey" loading="lazy"/><figcaption>parse-js-SpiderMonkey</figcaption></figure>
<p>在 Firefox 和 SpiderNode 中使用的 Mozilla JavaScript 引擎 SpiderMonkey 的做法略有不同。他们有两个优化编译器。解释器先让 Baseline 编译器优化，生成稍微优化的代码，然后 IonMonkey 编译器结合运行代码时收集的分析数据，生成高度优化的代码。如果推测优化失败，IonMonkey 会回退到 Baseline 的代码。</p>
<figure class="rehype-figure"><img src="https://cdn.jsdelivr.net/gh/marsk6/image-center@master/parse-js-charkra.png" alt="parse-js-charkra" loading="lazy"/><figcaption>parse-js-charkra</figcaption></figure>
<p>Edge 和 Node-ChakraCore 中使用的 Microsoft JavaScript 引擎 Chakra 和 SpiderMonkey 有非常相似的设置，带有两个优化编译器。解释器先让 SimpleJIT（这里的 JIT 代表即时编译器）它会生成稍微优化的代码，然后 FullJIT 编译器结合分析数据，生成高度优化的代码。</p>
<figure class="rehype-figure"><img src="https://cdn.jsdelivr.net/gh/marsk6/image-center@master/parse-js-jscore.png" alt="parse-js-jscore" loading="lazy"/><figcaption>parse-js-jscore</figcaption></figure>
<p>JavaScriptCore（JSC）是 Apple 的 JavaScript 引擎，用于 Safari 和 React Native，通过三种不同的优化编译器将代码优化发挥到了极致。LLInt（Low-Level Interpreter），先让 Baseline 编译器优化，再到 DFG（Data Flow Graph）编译器，最后到 FTL（Faster Than Light）编译器。</p>
<p>为什么有些引擎有多个优化编译器？这都是关于权衡取舍的，一方面解释器可以快速生成字节码去运行代码，但字节码通常效率不高；另一方面，优化编译器需要更长的时间，但最终会生成更高效的机器代码。一些引擎选择添加多个具有不同时间/效率特征的优化编译器，允许以额外的复杂性为代价对这些权衡进行更细粒度的控制。另一个权衡与内存使用有关。</p>
<p>以上我们说明了各个 JavaScript 引擎在解释器和优化编译器运行流程方面的区别。但除了这些差异之外，在较高的层次上，所有 JavaScript 引擎都具有相同的架构：有一个解析器和某种解释器/编译器运行流程。</p>
<h2 id="javascript-object-model"><a aria-hidden="true" tabindex="-1" href="#javascript-object-model"><span class="icon icon-link"></span></a>JavaScript Object Model</h2>
<p>让我们具体分析某些方面的实现方式来了解 JavaScript 引擎还有哪些共同点。</p>
<p>例如，JavaScript 引擎如何实现 JavaScript 对象模型，它们使用哪些技巧来加速访问 JavaScript 对象的属性？事实证明，所有主要引擎都实现非常类似。</p>
<p>ECMAScript 规范本质上将所有对象定义为字典，字符串键映射到属性 <code>descriptor</code>。</p>
<figure class="rehype-figure"><img src="https://cdn.jsdelivr.net/gh/marsk6/image-center@master/js-object.png" alt="js-object" loading="lazy"/><figcaption>js-object</figcaption></figure>
<p>除了 <code>[[Value]]</code> 本身，规范定义了这些属性：</p>
<ul>
<li><code>[[Writable]]</code> 指属性是否赋值</li>
<li><code>[[Enumerable]]</code> 指属性是否被枚举</li>
<li><code>[[Configurable]]</code> 指是否可以删除该属性
<code>[[ ]]</code> 符号看起来很特别，表示这个属性不直接暴露给 JavaScript。你可以使用 <code>Object.getOwnPropertyDescriptor</code> API 获取的对象属性的属性描述符：</li>
</ul>
<div class="pre-copy"><div class="pre-copy-button pre-copy-button--fade-out" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-copy"><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></div><pre class="language-js"><code class="language-js code-highlight"><span class="code-line line-number" line="1"><span class="line-suffix"></span><span class="token keyword">const</span> object <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token number">42</span> <span class="token punctuation">}</span>
</span><span class="code-line line-number" line="2"><span class="line-suffix"></span><span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> <span class="token string">&#x27;foo&#x27;</span><span class="token punctuation">)</span>
</span><span class="code-line line-number" line="3"><span class="line-suffix"></span><span class="token comment">// → { value: 42, writable: true, enumerable: true, configurable: true }</span>
</span></code></pre></div>
<p>好的，这就是 JavaScript 定义对象的方式。数组呢？</p>
<p>你可以将数组视为对象的特例。一个区别是数组对数组索引有特殊处理。这里数组索引是 ECMAScript 规范中的一个特殊术语。在 JavaScript 中，数组成员限制为 2³²−1 个。数组索引是该限制内的任何有效索引，即从 0 到 2³²−2 的任何整数。</p>
<p>另一个区别是数组还有一个神奇的长度属性。</p>
<div class="pre-copy"><div class="pre-copy-button pre-copy-button--fade-out" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-copy"><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></div><pre class="language-js"><code class="language-js code-highlight"><span class="code-line line-number" line="1"><span class="line-suffix"></span><span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#x27;a&#x27;</span><span class="token punctuation">,</span> <span class="token string">&#x27;b&#x27;</span><span class="token punctuation">]</span>
</span><span class="code-line line-number" line="2"><span class="line-suffix"></span>array<span class="token punctuation">.</span><span class="token property-access">length</span> <span class="token comment">// → 2</span>
</span><span class="code-line line-number" line="3"><span class="line-suffix"></span>array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&#x27;c&#x27;</span>
</span><span class="code-line line-number" line="4"><span class="line-suffix"></span>array<span class="token punctuation">.</span><span class="token property-access">length</span> <span class="token comment">// → 3</span>
</span></code></pre></div>
<p>在此示例中，数组在创建时的长度为 2，然后我们将另一个元素赋值给索引 2 处，长度自动更新。</p>
<p>JavaScript 对 array 的定义类似 object。例如，包括数组索引在内的所有键名都明确表示为字符串。数组中的第一个元素存储在键名 <code>0</code> 下。</p>
<figure class="rehype-figure"><img src="https://cdn.jsdelivr.net/gh/marsk6/image-center@master/js-array-define.png" alt="js-array-define" loading="lazy"/><figcaption>js-array-define</figcaption></figure>
<p><code>length</code> 只是另一个不可枚举和不可删除的属性。</p>
<p>当将元素添加到数组后，JavaScript 会自动更新 <code>length</code> 的 <code>[[value]]</code></p>
<figure class="rehype-figure"><img src="https://cdn.jsdelivr.net/gh/marsk6/image-center@master/js-array-define-2.png" alt="js-array-define-2" loading="lazy"/><figcaption>js-array-define-2</figcaption></figure>
<h2 id="优化属性访问"><a aria-hidden="true" tabindex="-1" href="#优化属性访问"><span class="icon icon-link"></span></a>优化属性访问</h2>
<p>现在我们知道了 object 是在 JavaScript 中的定义，让我们深入研究 JavaScript 引擎如何有效地处理对象。</p>
<p>纵观 JavaScript 程序，访问属性是目前最常见的操作。对于 JavaScript 引擎来说，快速访问属性是至关重要的。</p>
<div class="pre-copy"><div class="pre-copy-button pre-copy-button--fade-out" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-copy"><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></div><pre class="language-js"><code class="language-js code-highlight"><span class="code-line line-number" line="1"><span class="line-suffix"></span><span class="token keyword">const</span> object <span class="token operator">=</span> <span class="token punctuation">{</span>
</span><span class="code-line line-number" line="2"><span class="line-suffix"></span>  <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token string">&#x27;bar&#x27;</span><span class="token punctuation">,</span>
</span><span class="code-line line-number" line="3"><span class="line-suffix"></span>  <span class="token literal-property property">baz</span><span class="token operator">:</span> <span class="token string">&#x27;qux&#x27;</span><span class="token punctuation">,</span>
</span><span class="code-line line-number" line="4"><span class="line-suffix"></span><span class="token punctuation">}</span>
</span><span class="code-line line-number" line="5"><span class="line-suffix"></span>
</span><span class="code-line line-number" line="6"><span class="line-suffix"></span><span class="token comment">// Here, we’re accessing the property `foo` on `object`:</span>
</span><span class="code-line line-number" line="7"><span class="line-suffix"></span><span class="token function">doSomething</span><span class="token punctuation">(</span>object<span class="token punctuation">.</span><span class="token property-access">foo</span><span class="token punctuation">)</span>
</span><span class="code-line line-number" line="8"><span class="line-suffix"></span><span class="token comment">//</span>
</span></code></pre></div>
<h3 id="shapes"><a aria-hidden="true" tabindex="-1" href="#shapes"><span class="icon icon-link"></span></a>Shapes</h3>
<p>在 JavaScript 程序中，多个对象具有相同的属性键是很常见，这些对象具有相同的 <em>shape</em>。</p>
<div class="pre-copy"><div class="pre-copy-button pre-copy-button--fade-out" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-copy"><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></div><pre class="language-js"><code class="language-js code-highlight"><span class="code-line line-number" line="1"><span class="line-suffix"></span><span class="token keyword">const</span> object1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span>
</span><span class="code-line line-number" line="2"><span class="line-suffix"></span><span class="token keyword">const</span> object2 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">4</span> <span class="token punctuation">}</span>
</span><span class="code-line line-number" line="3"><span class="line-suffix"></span><span class="token comment">// `object1` and `object2` have the same shape.</span>
</span></code></pre></div>
<p>在具有相同 shape 的对象上访问相同的属性也很常见：</p>
<div class="pre-copy"><div class="pre-copy-button pre-copy-button--fade-out" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-copy"><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></div><pre class="language-js"><code class="language-js code-highlight"><span class="code-line line-number" line="1"><span class="line-suffix"></span><span class="token keyword">function</span> <span class="token function">logX</span><span class="token punctuation">(</span><span class="token parameter">object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line line-number" line="2"><span class="line-suffix"></span>  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>object<span class="token punctuation">.</span><span class="token property-access">x</span><span class="token punctuation">)</span>
</span><span class="code-line line-number" line="3"><span class="line-suffix"></span>  <span class="token comment">//          ^^^^^^^^</span>
</span><span class="code-line line-number" line="4"><span class="line-suffix"></span><span class="token punctuation">}</span>
</span><span class="code-line line-number" line="5"><span class="line-suffix"></span>
</span><span class="code-line line-number" line="6"><span class="line-suffix"></span><span class="token keyword">const</span> object1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span>
</span><span class="code-line line-number" line="7"><span class="line-suffix"></span><span class="token keyword">const</span> object2 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">4</span> <span class="token punctuation">}</span>
</span><span class="code-line line-number" line="8"><span class="line-suffix"></span>
</span><span class="code-line line-number" line="9"><span class="line-suffix"></span><span class="token function">logX</span><span class="token punctuation">(</span>object1<span class="token punctuation">)</span>
</span><span class="code-line line-number" line="10"><span class="line-suffix"></span><span class="token function">logX</span><span class="token punctuation">(</span>object2<span class="token punctuation">)</span>
</span></code></pre></div>
<p>考虑到这一点，JavaScript 引擎可以根据对象的形状优化对象属性访问。</p>
<p>假设我们有一个具有属性 <code>x</code> 和 <code>y</code> 的对象，它使用我们之前讨论过的字典数据结构：它包含字符串形式的键，这些键指向它们各自的属性 <code>descriptor</code>。</p>
<figure class="rehype-figure"><img src="https://cdn.jsdelivr.net/gh/marsk6/image-center@master/js-object-2.png" alt="js-object-2" loading="lazy"/><figcaption>js-object-2</figcaption></figure>
<p>如果你访问某个属性，例如 <code>object.y</code>，JavaScript 引擎在 <code>JSObject</code> 中查找键 <code>y</code>，然后加载相应的属性 <code>descriptor</code>，最后返回 <code>[[Value]]</code>。</p>
<p>但是这些属性 <code>descriptor</code> 存放在内存的什么地方呢？我们应该将它们存储为 <code>JSObject</code> 的一部分吗？如果我们碰到更多具有这种 <code>shape</code> 的对象，那么把完整的属性相关信息存储在 <code>JSObject</code> 上是一种浪费，因为这些对象的属性名称是重复的。作为一种优化，引擎单独存储对象的 <code>shape</code>。</p>
<figure class="rehype-figure"><img src="https://cdn.jsdelivr.net/gh/marsk6/image-center@master/js-object-2-1.png" alt="js-object-2-1" loading="lazy"/><figcaption>js-object-2-1</figcaption></figure>
<p>除了 <code>[[Value]]</code>，<code>Shape</code> 包含所有属性名称和 <code>descriptor</code>。<code>Shape</code> 包含一个偏移量，表示属性值在 <code>JSObject</code> 的偏移量，因此 JavaScript 引擎知道在哪里可以找到这些值。每个具有相同形状的 <code>JSObject</code> 都指向这个 <code>Shape</code> 实例。现在每个 <code>JSObject</code> 只需存储针对该对象的值了。</p>
<figure class="rehype-figure"><img src="https://cdn.jsdelivr.net/gh/marsk6/image-center@master/js-object-3.png" alt="js-object-3" loading="lazy"/><figcaption>js-object-3</figcaption></figure>
<p>当我们有多个对象时，好处就很明显了。不管有多少对象，只要它们的形状相同，我们只需要存储一个 <code>shape</code> 和属性信息！</p>
<p>所有 JavaScript 引擎都使用 <code>shape</code> 作为优化，但它们并不都称它们为 <code>shape</code>：</p>
<ul>
<li>学术论文称它们为 <em>Hidden Classes</em>（区分 JavaScript 类）</li>
<li>V8 称它们为 <em>Maps</em>（区分 JavaScript <code>Maps</code>）</li>
<li>Chakra 称它们为<em>Types</em>（区分 JavaScript 的变量类型和 <code>typeof</code>）</li>
<li>JavaScriptCore 称它们为 <em>Structures</em></li>
<li>SpiderMonkey 称它们为 <em>Shapes</em></li>
</ul>
<p>在整篇文章中，我们将继续使用术语 <em>shapes</em>。</p>
<h3 id="shape-的转变链和-trees"><a aria-hidden="true" tabindex="-1" href="#shape-的转变链和-trees"><span class="icon icon-link"></span></a>shape 的转变链和 trees</h3>
<p>如果你有一个具有特定形状的对象，然后你给它添加了一个属性，会发生什么？JavaScript 引擎如何处理新的 <code>shape</code>？</p>
<div class="pre-copy"><div class="pre-copy-button pre-copy-button--fade-out" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-copy"><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></div><pre class="language-js"><code class="language-js code-highlight"><span class="code-line line-number" line="1"><span class="line-suffix"></span><span class="token keyword">const</span> object <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</span><span class="code-line line-number" line="2"><span class="line-suffix"></span>object<span class="token punctuation">.</span><span class="token property-access">x</span> <span class="token operator">=</span> <span class="token number">5</span>
</span><span class="code-line line-number" line="3"><span class="line-suffix"></span>object<span class="token punctuation">.</span><span class="token property-access">y</span> <span class="token operator">=</span> <span class="token number">6</span>
</span></code></pre></div>
<p>这些 shape 在 JavaScript 引擎中形成所谓的转变链（<em>transition chains</em>）。这是一个例子：</p>
<figure class="rehype-figure"><img src="https://cdn.jsdelivr.net/gh/marsk6/image-center@master/js-object-4.png" alt="js-object-4" loading="lazy"/><figcaption>js-object-4</figcaption></figure>
<p>该对象开始时没有任何属性，因此它指向空 <code>shape</code>。下一条语句添加属性 <code>x</code> 并赋值 <code>5</code>，因此 <code>shape</code> 转换为包含属性 <code>x</code>，并将值 <code>5</code> 添加到 <code>JSObject</code> 偏移量 0 处。下一行添加属性 <code>y</code>，因此又转换为包含 <code>x</code> 和 <code>y</code> 的另一个 <code>shape</code>，并将值 6 附加到 <code>JSObject</code> 偏移量 1 处。</p>
<blockquote>
<p>注意：添加属性的顺序会影响 <code>shape</code>。例如，<code>{ x: 4, y: 5 }</code> 的形状与 <code>{ y: 5, x: 4 }</code> 不同。</p>
</blockquote>
<p>我们也无需要为每个 <code>Shape</code> 存储完整的属性表。相反，每个 <code>Shape</code> 只需要知道它引入的新属性。例如，我们不必在最后一个 <code>shape</code> 中存储 <code>x</code> 的信息，因为它可以在链中的前面的位置找到。为了使这项工作有效，每个 <code>Shape</code> 都链接回其以前的 <code>shape</code>：</p>
<figure class="rehype-figure"><img src="https://cdn.jsdelivr.net/gh/marsk6/image-center@master/js-object-5.png" alt="js-object-5" loading="lazy"/><figcaption>js-object-5</figcaption></figure>
<p>如果你访问 <code>o.x</code>，JavaScript 引擎会在 <code>shape</code> 链上查找属性 <code>x</code>，直到找到引入属性 <code>x</code> 的 <code>Shape</code>。</p>
<p>但是，如果无法创建过渡链会怎样？例如，如果您有两个空对象，并为每个对象添加不同的属性，会怎样？</p>
<div class="pre-copy"><div class="pre-copy-button pre-copy-button--fade-out" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-copy"><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></div><pre class="language-js"><code class="language-js code-highlight"><span class="code-line line-number" line="1"><span class="line-suffix"></span><span class="token keyword">const</span> object1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</span><span class="code-line line-number" line="2"><span class="line-suffix"></span>object1<span class="token punctuation">.</span><span class="token property-access">x</span> <span class="token operator">=</span> <span class="token number">5</span>
</span><span class="code-line line-number" line="3"><span class="line-suffix"></span><span class="token keyword">const</span> object2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</span><span class="code-line line-number" line="4"><span class="line-suffix"></span>object2<span class="token punctuation">.</span><span class="token property-access">y</span> <span class="token operator">=</span> <span class="token number">6</span>
</span></code></pre></div>
<p>在这种情况下，我们用分叉，而不是链式，我们最终得到一个转变树（<em>transition tree</em>）：</p>
<figure class="rehype-figure"><img src="https://cdn.jsdelivr.net/gh/marsk6/image-center@master/js-object-6.png" alt="js-object-6" loading="lazy"/><figcaption>js-object-6</figcaption></figure>
<p>在这里，我们创建了一个空对象 <code>a</code>，然后添加属性 <code>x</code>。最终得到一个 <code>JSObject</code> 和两个 <code>shape</code></p>
<p>再创建空对象 <code>b</code>，然后添加属性 <code>y</code>。我们最终得到两个 <code>shape</code> 链，总共三个 <code>shape</code>。这是否意味着我们总是从空 <code>shape</code> 开始？不必要。引擎对包含属性的对象字面量做了一些优化。假设我们从空对象字面量开始添加 <code>x</code>，或者有一个已经包含 <code>x</code> 的对象字面量：</p>
<div class="pre-copy"><div class="pre-copy-button pre-copy-button--fade-out" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-copy"><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></div><pre class="language-js"><code class="language-js code-highlight"><span class="code-line line-number" line="1"><span class="line-suffix"></span><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</span><span class="code-line line-number" line="2"><span class="line-suffix"></span>a<span class="token punctuation">.</span><span class="token property-access">x</span> <span class="token operator">=</span> <span class="token number">6</span>
</span><span class="code-line line-number" line="3"><span class="line-suffix"></span><span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">6</span> <span class="token punctuation">}</span>
</span></code></pre></div>
<p>在开始，我们从空的 <code>shape</code> 链接到含 <code>x</code> 的 <code>shape</code>。</p>
<p>对于 <code>b</code>，直接创建包含 <code>x</code> 的 <code>shape</code> 而不是从一个空的 <code>shape</code> 开始。</p>
<figure class="rehype-figure"><img src="https://cdn.jsdelivr.net/gh/marsk6/image-center@master/js-object-7.png" alt="js-object-7" loading="lazy"/><figcaption>js-object-7</figcaption></figure>
<p>Benedikt 的一篇博客 <a href="https://medium.com/@bmeurer/surprising-polymorphism-in-react-applications-63015b50abc" target="_blank" rel="nofollow">Surprising polymorphism in React applications</a> 讨论了这些细节如何影响代码的性能。</p>
<p>举个例子，一个 point 对象包含 <code>x</code>，<code>y</code>，<code>z</code> 3 个属性。</p>
<div class="pre-copy"><div class="pre-copy-button pre-copy-button--fade-out" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-copy"><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></div><pre class="language-js"><code class="language-js code-highlight"><span class="code-line line-number" line="1"><span class="line-suffix"></span><span class="token keyword">const</span> point <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</span><span class="code-line line-number" line="2"><span class="line-suffix"></span>point<span class="token punctuation">.</span><span class="token property-access">x</span> <span class="token operator">=</span> <span class="token number">4</span>
</span><span class="code-line line-number" line="3"><span class="line-suffix"></span>point<span class="token punctuation">.</span><span class="token property-access">y</span> <span class="token operator">=</span> <span class="token number">5</span>
</span><span class="code-line line-number" line="4"><span class="line-suffix"></span>point<span class="token punctuation">.</span><span class="token property-access">z</span> <span class="token operator">=</span> <span class="token number">6</span>
</span></code></pre></div>
<p>按之前的学习，这会在内存中创建一个具有 3 个 <code>shape</code>（不包括空 <code>shape</code>）。当访问该对象的属性 <code>x</code> 时，JavaScript 引擎从链表尾向前查找有 <code>x</code> 的 <code>shape</code>。</p>
<figure class="rehype-figure"><img src="https://cdn.jsdelivr.net/gh/marsk6/image-center@master/js-object-8.png" alt="js-object-8" loading="lazy"/><figcaption>js-object-8</figcaption></figure>
<p>当类似的操作多了，那将会非常慢。找到属性的时间是 $O(n)$，即与对象的属性数量成线性关系。为了加快搜索属性的速度，JavaScript 引擎添加了一个 <code>ShapeTable</code> 数据结构。这个 <code>ShapeTable</code> 是一个字典，将属性键映射到引入给定属性的各个 <code>Shape</code>。</p>
<figure class="rehype-figure"><img src="https://cdn.jsdelivr.net/gh/marsk6/image-center@master/js-object-9.png" alt="js-object-9" loading="lazy"/><figcaption>js-object-9</figcaption></figure>
<p>等一下，现在又变成字典查找......当初就是用 <code>shape</code> 链优化字典查找！那么，为什么 <code>shape</code> 上还有优化呢？原因是 <code>shape</code> 启用了另一种称为内联缓存（<em>Inline Caches</em>）的优化。</p>
<h3 id="inline-caches-ics"><a aria-hidden="true" tabindex="-1" href="#inline-caches-ics"><span class="icon icon-link"></span></a>Inline Caches (ICs)</h3>
<p><code>shape</code> 背后的主要动机是 Inline Caches 或 ICs 的概念。ICs 是使 JavaScript 快速运行的关键要素！JavaScript 引擎使用 ICs 来存储有关在何处查找对象属性的信息，以减少昂贵的查找次数。</p>
<p>例如函数 <code>getX</code>：</p>
<figure class="rehype-figure"><img src="https://cdn.jsdelivr.net/gh/marsk6/image-center@master/js-object-10.png" alt="js-object-10" loading="lazy"/><figcaption>js-object-10</figcaption></figure>
<p>第一个 <code>get_by_id</code> 指令从第一个参数 (<code>arg1</code>) 加载属性 <code>x</code> 并将结果存储到 <code>loc0</code>。第二条指令返回我们存储到 <code>loc0</code> 的内容。</p>
<p>JSC 还在 <code>get_by_id</code> 指令中嵌入了一个 Inline Cache，它由两个未初始化的 slot（N/A 和 N/A）组成。</p>
<figure class="rehype-figure"><img src="https://cdn.jsdelivr.net/gh/marsk6/image-center@master/js-object-11.png" alt="js-object-11" loading="lazy"/><figcaption>js-object-11</figcaption></figure>
<p>现在假设我们调用 <code>getX</code> 并传参 <code>{ x: &#x27;a&#x27; }</code>。那么该对象会有一个 <code>shape</code>。当第一次执行函数时，<code>get_by_id</code> 指令查找 <code>x</code> 的值。然后 ICs 会存储该对象的 <code>shape</code> 和属性的 <code>offset</code> 值</p>
<figure class="rehype-figure"><img src="https://cdn.jsdelivr.net/gh/marsk6/image-center@master/js-object-12.png" alt="js-object-12" loading="lazy"/><figcaption>js-object-12</figcaption></figure>
<p>后续运行时，ICs 只需要比较 <code>shape</code>，如果和之前一样，就从存储的 offset 中加载值即可。具体来说，如果 JavaScript 引擎看到具有 IC 之前记录的形状的对象，它根本不再需要访问属性信息——相反，可以完全跳过昂贵的属性信息查找。这比每次都查找属性要快得多。</p>
<figure class="rehype-figure"><img src="https://cdn.jsdelivr.net/gh/marsk6/image-center@master/js-object-13.png" alt="js-object-13" loading="lazy"/><figcaption>js-object-13</figcaption></figure>
<h3 id="有效存储数组"><a aria-hidden="true" tabindex="-1" href="#有效存储数组"><span class="icon icon-link"></span></a>有效存储数组</h3>
<p>对于数组，通常存储的属性是数组索引，属性的值称为数组元素。为数组中的每个数组元素存储属性特性会浪费内存。相反，JavaScript 引擎使用数组索引属性在默认情况下是可写、可枚举和可配置的这一事实，并将数组元素与其他命名属性分开存储。</p>
<p>例如 array 的存储形式</p>
<div class="pre-copy"><div class="pre-copy-button pre-copy-button--fade-out" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-copy"><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></div><pre class="language-js"><code class="language-js code-highlight"><span class="code-line line-number" line="1"><span class="line-suffix"></span><span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#x27;#jsconfeu&#x27;</span><span class="token punctuation">]</span>
</span></code></pre></div>
<p>和对象类似，但值存在哪里呢？</p>
<figure class="rehype-figure"><img src="https://cdn.jsdelivr.net/gh/marsk6/image-center@master/js-object-14.png" alt="js-object-14" loading="lazy"/><figcaption>js-object-14</figcaption></figure>
<p>每个数组都有一个单独的 <code>Elements</code>（<em>elements backing</em>）存储所有数组索引的属性值。JavaScript 引擎不必为每个索引存储属性特性，因为它们通常都是可写、可枚举和可配置的。</p>
<figure class="rehype-figure"><img src="https://cdn.jsdelivr.net/gh/marsk6/image-center@master/js-object-15.png" alt="js-object-15" loading="lazy"/><figcaption>js-object-15</figcaption></figure>
<p>但是，如果更改数组索引的属性特性怎么办？</p>
<div class="pre-copy"><div class="pre-copy-button pre-copy-button--fade-out" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tabler-icon tabler-icon-copy"><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></div><pre class="language-js"><code class="language-js code-highlight"><span class="code-line line-number" line="1"><span class="line-suffix"></span><span class="token comment">// Please don’t ever do this!</span>
</span><span class="code-line line-number" line="2"><span class="line-suffix"></span><span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">defineProperty</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">&#x27;0&#x27;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
</span><span class="code-line line-number" line="3"><span class="line-suffix"></span>  <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token string">&#x27;Oh noes!!1&#x27;</span><span class="token punctuation">,</span>
</span><span class="code-line line-number" line="4"><span class="line-suffix"></span>  <span class="token literal-property property">writable</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
</span><span class="code-line line-number" line="5"><span class="line-suffix"></span>  <span class="token literal-property property">enumerable</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
</span><span class="code-line line-number" line="6"><span class="line-suffix"></span>  <span class="token literal-property property">configurable</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
</span><span class="code-line line-number" line="7"><span class="line-suffix"></span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</span></code></pre></div>
<p>上面的代码片段定义了一个名为 <code>0</code> 的属性（恰好是一个数组索引），并修改了属性特性。在这种边缘情况下，JavaScript 引擎将整个 <code>Elements</code> 存储字典。</p>
<figure class="rehype-figure"><img src="https://cdn.jsdelivr.net/gh/marsk6/image-center@master/js-object-16.png" alt="js-object-16" loading="lazy"/><figcaption>js-object-16</figcaption></figure>
<p>即使只有一个数组元素具有非默认属性，整个数组的 <code>Elements</code> 也会进入这种缓慢且低效的模式。避免在数组索引上使用 <code>Object.defineProperty</code>！</p>
<h3 id="总结"><a aria-hidden="true" tabindex="-1" href="#总结"><span class="icon icon-link"></span></a>总结</h3>
<p>我们了解了 JavaScript 引擎如何存储对象和数组，以及形状和 ICs 如何帮助优化它们的常见操作。基于这些知识，我们确定了一些有助于提高性能的实用 JavaScript 编码技巧：</p>
<ul>
<li>总是以相同的方式初始化你的对象，所以它们不会有不同的 <code>shape</code>。</li>
<li>不要乱用数组元素的 property 属性，这样可以高效地存储和操作它们。</li>
</ul></section></article><footer class="flex flex-col gap-6 mt-6"><section class="flex"><div class="flex-shrink-0 basis-2/4 text-ellipsis overflow-hidden"></div><div class="flex-shrink-0 text-ellipsis overflow-hidden ml-auto"></div></section></footer></section></section><div class="text-center text-xs text-gray-400 my-4">© 2021 - <!-- -->2023<!-- --> <!-- -->Hea的web博客<!-- -->. Powered by Next.js. Hosted on GitHub.</div></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"__typename":"Post","slug":"zh-cn-js-engine-shape-inline-cache","title":"译 - JavaScript 引擎底层：Shapes 和 Inline Caches","tags":[{"__typename":"Tag","name":"翻译文章"},{"__typename":"Tag","name":"性能优化"}],"category":null,"ctime":1666060980000,"mtime":0,"date":"10-18","content":"\n\u003e 原文 [JavaScript engine fundamentals: Shapes and Inline Caches · Mathias Bynens](https://mathiasbynens.be/notes/shapes-ics)\n\n本文描述了所有 JavaScript 引擎共有的一些关键基础知识——而不仅是 V8。作为 JavaScript 开发人员，深入了解 JavaScript 引擎的工作原理可以帮你了解代码的性能点。\n\n## JavaScript 引擎编译流程\n\n从你编写的 JavaScript 代码开始，JavaScript 引擎解析源代码并将其转换为抽象语法树 (AST)，之后解释器基于 AST 生成字节码。\n\n![parse-js](https://cdn.jsdelivr.net/gh/marsk6/image-center@master/parse-js.png)\n\n为了使其运行得更快，会把生成的字节码与编译分析数据一起发送到优化编译器。优化编译器根据编译分析数据做出某些假设，然后生成高度优化的机器代码。如果某些假设被证明是不对的，则优化编译器会取消优化并返回给解释器。\n\n### 解释器/编译器的工作流程\n\n现在，让我们分析这个流程中实际运行 JavaScript 代码的部分，即代码被解释和优化的部分，并回顾一下主要 JavaScript 引擎之间的一些差异。\n\n通常，有一个包含解释器和优化编译器的流程。解释器快速生成未优化的字节码，优化编译器需要更长的时间，但最终生成高度优化的机器码。\n\n![parse-js-2](https://cdn.jsdelivr.net/gh/marsk6/image-center@master/parse-js-2.png)\n\n这个流程基本就是 V8 的工作方式\n\n![parse-js-v8](https://cdn.jsdelivr.net/gh/marsk6/image-center@master/parse-js-v8.png)\n\nV8 中的解释器称为 Ignition，负责生成和执行字节码。当它运行字节码时，它会收集分析数据，例如经常调用的函数，这些数据可用于加快以后的执行速度。生成的字节码和分析数据被传递给我们的优化编译器 TurboFan，根据分析数据生成高度优化的机器代码。\n\n![parse-js-SpiderMonkey](https://cdn.jsdelivr.net/gh/marsk6/image-center@master/parse-js-SpiderMonkey.png)\n\n在 Firefox 和 SpiderNode 中使用的 Mozilla JavaScript 引擎 SpiderMonkey 的做法略有不同。他们有两个优化编译器。解释器先让 Baseline 编译器优化，生成稍微优化的代码，然后 IonMonkey 编译器结合运行代码时收集的分析数据，生成高度优化的代码。如果推测优化失败，IonMonkey 会回退到 Baseline 的代码。\n\n![parse-js-charkra](https://cdn.jsdelivr.net/gh/marsk6/image-center@master/parse-js-charkra.png)\n\nEdge 和 Node-ChakraCore 中使用的 Microsoft JavaScript 引擎 Chakra 和 SpiderMonkey 有非常相似的设置，带有两个优化编译器。解释器先让 SimpleJIT（这里的 JIT 代表即时编译器）它会生成稍微优化的代码，然后 FullJIT 编译器结合分析数据，生成高度优化的代码。\n\n![parse-js-jscore](https://cdn.jsdelivr.net/gh/marsk6/image-center@master/parse-js-jscore.png)\n\nJavaScriptCore（JSC）是 Apple 的 JavaScript 引擎，用于 Safari 和 React Native，通过三种不同的优化编译器将代码优化发挥到了极致。LLInt（Low-Level Interpreter），先让 Baseline 编译器优化，再到 DFG（Data Flow Graph）编译器，最后到 FTL（Faster Than Light）编译器。\n\n为什么有些引擎有多个优化编译器？这都是关于权衡取舍的，一方面解释器可以快速生成字节码去运行代码，但字节码通常效率不高；另一方面，优化编译器需要更长的时间，但最终会生成更高效的机器代码。一些引擎选择添加多个具有不同时间/效率特征的优化编译器，允许以额外的复杂性为代价对这些权衡进行更细粒度的控制。另一个权衡与内存使用有关。\n\n以上我们说明了各个 JavaScript 引擎在解释器和优化编译器运行流程方面的区别。但除了这些差异之外，在较高的层次上，所有 JavaScript 引擎都具有相同的架构：有一个解析器和某种解释器/编译器运行流程。\n\n## JavaScript Object Model\n\n让我们具体分析某些方面的实现方式来了解 JavaScript 引擎还有哪些共同点。\n\n例如，JavaScript 引擎如何实现 JavaScript 对象模型，它们使用哪些技巧来加速访问 JavaScript 对象的属性？事实证明，所有主要引擎都实现非常类似。\n\nECMAScript 规范本质上将所有对象定义为字典，字符串键映射到属性 `descriptor`。\n\n![js-object](https://cdn.jsdelivr.net/gh/marsk6/image-center@master/js-object.png)\n\n除了 `[[Value]]` 本身，规范定义了这些属性：\n\n- `[[Writable]]` 指属性是否赋值\n- `[[Enumerable]]` 指属性是否被枚举\n- `[[Configurable]]` 指是否可以删除该属性\n  `[[ ]]` 符号看起来很特别，表示这个属性不直接暴露给 JavaScript。你可以使用 `Object.getOwnPropertyDescriptor` API 获取的对象属性的属性描述符：\n\n```js\nconst object = { foo: 42 }\nObject.getOwnPropertyDescriptor(object, 'foo')\n// → { value: 42, writable: true, enumerable: true, configurable: true }\n```\n\n好的，这就是 JavaScript 定义对象的方式。数组呢？\n\n你可以将数组视为对象的特例。一个区别是数组对数组索引有特殊处理。这里数组索引是 ECMAScript 规范中的一个特殊术语。在 JavaScript 中，数组成员限制为 2³²−1 个。数组索引是该限制内的任何有效索引，即从 0 到 2³²−2 的任何整数。\n\n另一个区别是数组还有一个神奇的长度属性。\n\n```js\nconst array = ['a', 'b']\narray.length // → 2\narray[2] = 'c'\narray.length // → 3\n```\n\n在此示例中，数组在创建时的长度为 2，然后我们将另一个元素赋值给索引 2 处，长度自动更新。\n\nJavaScript 对 array 的定义类似 object。例如，包括数组索引在内的所有键名都明确表示为字符串。数组中的第一个元素存储在键名 `0` 下。\n\n![js-array-define](https://cdn.jsdelivr.net/gh/marsk6/image-center@master/js-array-define.png)\n\n`length` 只是另一个不可枚举和不可删除的属性。\n\n当将元素添加到数组后，JavaScript 会自动更新 `length` 的 `[[value]]`\n\n![js-array-define-2](https://cdn.jsdelivr.net/gh/marsk6/image-center@master/js-array-define-2.png)\n\n## 优化属性访问\n\n现在我们知道了 object 是在 JavaScript 中的定义，让我们深入研究 JavaScript 引擎如何有效地处理对象。\n\n纵观 JavaScript 程序，访问属性是目前最常见的操作。对于 JavaScript 引擎来说，快速访问属性是至关重要的。\n\n```js\nconst object = {\n  foo: 'bar',\n  baz: 'qux',\n}\n\n// Here, we’re accessing the property `foo` on `object`:\ndoSomething(object.foo)\n//\n```\n\n### Shapes\n\n在 JavaScript 程序中，多个对象具有相同的属性键是很常见，这些对象具有相同的 _shape_。\n\n```js\nconst object1 = { x: 1, y: 2 }\nconst object2 = { x: 3, y: 4 }\n// `object1` and `object2` have the same shape.\n```\n\n在具有相同 shape 的对象上访问相同的属性也很常见：\n\n```js\nfunction logX(object) {\n  console.log(object.x)\n  //          ^^^^^^^^\n}\n\nconst object1 = { x: 1, y: 2 }\nconst object2 = { x: 3, y: 4 }\n\nlogX(object1)\nlogX(object2)\n```\n\n考虑到这一点，JavaScript 引擎可以根据对象的形状优化对象属性访问。\n\n假设我们有一个具有属性 `x` 和 `y` 的对象，它使用我们之前讨论过的字典数据结构：它包含字符串形式的键，这些键指向它们各自的属性 `descriptor`。\n\n![js-object-2](https://cdn.jsdelivr.net/gh/marsk6/image-center@master/js-object-2.png)\n\n如果你访问某个属性，例如 `object.y`，JavaScript 引擎在 `JSObject` 中查找键 `y`，然后加载相应的属性 `descriptor`，最后返回 `[[Value]]`。\n\n但是这些属性 `descriptor` 存放在内存的什么地方呢？我们应该将它们存储为 `JSObject` 的一部分吗？如果我们碰到更多具有这种 `shape` 的对象，那么把完整的属性相关信息存储在 `JSObject` 上是一种浪费，因为这些对象的属性名称是重复的。作为一种优化，引擎单独存储对象的 `shape`。\n\n![js-object-2-1](https://cdn.jsdelivr.net/gh/marsk6/image-center@master/js-object-2-1.png)\n\n除了 `[[Value]]`，`Shape` 包含所有属性名称和 `descriptor`。`Shape` 包含一个偏移量，表示属性值在 `JSObject` 的偏移量，因此 JavaScript 引擎知道在哪里可以找到这些值。每个具有相同形状的 `JSObject` 都指向这个 `Shape` 实例。现在每个 `JSObject` 只需存储针对该对象的值了。\n\n![js-object-3](https://cdn.jsdelivr.net/gh/marsk6/image-center@master/js-object-3.png)\n\n当我们有多个对象时，好处就很明显了。不管有多少对象，只要它们的形状相同，我们只需要存储一个 `shape` 和属性信息！\n\n所有 JavaScript 引擎都使用 `shape` 作为优化，但它们并不都称它们为 `shape`：\n\n- 学术论文称它们为 _Hidden Classes_（区分 JavaScript 类）\n- V8 称它们为 _Maps_（区分 JavaScript `Maps`）\n- Chakra 称它们为*Types*（区分 JavaScript 的变量类型和 `typeof`）\n- JavaScriptCore 称它们为 _Structures_\n- SpiderMonkey 称它们为 _Shapes_\n\n在整篇文章中，我们将继续使用术语 _shapes_。\n\n### shape 的转变链和 trees\n\n如果你有一个具有特定形状的对象，然后你给它添加了一个属性，会发生什么？JavaScript 引擎如何处理新的 `shape`？\n\n```js\nconst object = {}\nobject.x = 5\nobject.y = 6\n```\n\n这些 shape 在 JavaScript 引擎中形成所谓的转变链（_transition chains_）。这是一个例子：\n\n![js-object-4](https://cdn.jsdelivr.net/gh/marsk6/image-center@master/js-object-4.png)\n\n该对象开始时没有任何属性，因此它指向空 `shape`。下一条语句添加属性 `x` 并赋值 `5`，因此 `shape` 转换为包含属性 `x`，并将值 `5` 添加到 `JSObject` 偏移量 0 处。下一行添加属性 `y`，因此又转换为包含 `x` 和 `y` 的另一个 `shape`，并将值 6 附加到 `JSObject` 偏移量 1 处。\n\n\u003e 注意：添加属性的顺序会影响 `shape`。例如，`{ x: 4, y: 5 }` 的形状与 `{ y: 5, x: 4 }` 不同。\n\n我们也无需要为每个 `Shape` 存储完整的属性表。相反，每个 `Shape` 只需要知道它引入的新属性。例如，我们不必在最后一个 `shape` 中存储 `x` 的信息，因为它可以在链中的前面的位置找到。为了使这项工作有效，每个 `Shape` 都链接回其以前的 `shape`：\n\n![js-object-5](https://cdn.jsdelivr.net/gh/marsk6/image-center@master/js-object-5.png)\n\n如果你访问 `o.x`，JavaScript 引擎会在 `shape` 链上查找属性 `x`，直到找到引入属性 `x` 的 `Shape`。\n\n但是，如果无法创建过渡链会怎样？例如，如果您有两个空对象，并为每个对象添加不同的属性，会怎样？\n\n```js\nconst object1 = {}\nobject1.x = 5\nconst object2 = {}\nobject2.y = 6\n```\n\n在这种情况下，我们用分叉，而不是链式，我们最终得到一个转变树（_transition tree_）：\n\n![js-object-6](https://cdn.jsdelivr.net/gh/marsk6/image-center@master/js-object-6.png)\n\n在这里，我们创建了一个空对象 `a`，然后添加属性 `x`。最终得到一个 `JSObject` 和两个 `shape`\n\n再创建空对象 `b`，然后添加属性 `y`。我们最终得到两个 `shape` 链，总共三个 `shape`。这是否意味着我们总是从空 `shape` 开始？不必要。引擎对包含属性的对象字面量做了一些优化。假设我们从空对象字面量开始添加 `x`，或者有一个已经包含 `x` 的对象字面量：\n\n```js\nconst a = {}\na.x = 6\nconst b = { x: 6 }\n```\n\n在开始，我们从空的 `shape` 链接到含 `x` 的 `shape`。\n\n对于 `b`，直接创建包含 `x` 的 `shape` 而不是从一个空的 `shape` 开始。\n\n![js-object-7](https://cdn.jsdelivr.net/gh/marsk6/image-center@master/js-object-7.png)\n\nBenedikt 的一篇博客 [Surprising polymorphism in React applications](https://medium.com/@bmeurer/surprising-polymorphism-in-react-applications-63015b50abc) 讨论了这些细节如何影响代码的性能。\n\n举个例子，一个 point 对象包含 `x`，`y`，`z` 3 个属性。\n\n```js\nconst point = {}\npoint.x = 4\npoint.y = 5\npoint.z = 6\n```\n\n按之前的学习，这会在内存中创建一个具有 3 个 `shape`（不包括空 `shape`）。当访问该对象的属性 `x` 时，JavaScript 引擎从链表尾向前查找有 `x` 的 `shape`。\n\n![js-object-8](https://cdn.jsdelivr.net/gh/marsk6/image-center@master/js-object-8.png)\n\n当类似的操作多了，那将会非常慢。找到属性的时间是 $O(n)$，即与对象的属性数量成线性关系。为了加快搜索属性的速度，JavaScript 引擎添加了一个 `ShapeTable` 数据结构。这个 `ShapeTable` 是一个字典，将属性键映射到引入给定属性的各个 `Shape`。\n\n![js-object-9](https://cdn.jsdelivr.net/gh/marsk6/image-center@master/js-object-9.png)\n\n等一下，现在又变成字典查找......当初就是用 `shape` 链优化字典查找！那么，为什么 `shape` 上还有优化呢？原因是 `shape` 启用了另一种称为内联缓存（_Inline Caches_）的优化。\n\n### Inline Caches (ICs)\n\n`shape` 背后的主要动机是 Inline Caches 或 ICs 的概念。ICs 是使 JavaScript 快速运行的关键要素！JavaScript 引擎使用 ICs 来存储有关在何处查找对象属性的信息，以减少昂贵的查找次数。\n\n例如函数 `getX`：\n\n![js-object-10](https://cdn.jsdelivr.net/gh/marsk6/image-center@master/js-object-10.png)\n\n第一个 `get_by_id` 指令从第一个参数 (`arg1`) 加载属性 `x` 并将结果存储到 `loc0`。第二条指令返回我们存储到 `loc0` 的内容。\n\nJSC 还在 `get_by_id` 指令中嵌入了一个 Inline Cache，它由两个未初始化的 slot（N/A 和 N/A）组成。\n\n![js-object-11](https://cdn.jsdelivr.net/gh/marsk6/image-center@master/js-object-11.png)\n\n现在假设我们调用 `getX` 并传参 `{ x: 'a' }`。那么该对象会有一个 `shape`。当第一次执行函数时，`get_by_id` 指令查找 `x` 的值。然后 ICs 会存储该对象的 `shape` 和属性的 `offset` 值\n\n![js-object-12](https://cdn.jsdelivr.net/gh/marsk6/image-center@master/js-object-12.png)\n\n后续运行时，ICs 只需要比较 `shape`，如果和之前一样，就从存储的 offset 中加载值即可。具体来说，如果 JavaScript 引擎看到具有 IC 之前记录的形状的对象，它根本不再需要访问属性信息——相反，可以完全跳过昂贵的属性信息查找。这比每次都查找属性要快得多。\n\n![js-object-13](https://cdn.jsdelivr.net/gh/marsk6/image-center@master/js-object-13.png)\n\n### 有效存储数组\n\n对于数组，通常存储的属性是数组索引，属性的值称为数组元素。为数组中的每个数组元素存储属性特性会浪费内存。相反，JavaScript 引擎使用数组索引属性在默认情况下是可写、可枚举和可配置的这一事实，并将数组元素与其他命名属性分开存储。\n\n例如 array 的存储形式\n\n```js\nconst array = ['#jsconfeu']\n```\n\n和对象类似，但值存在哪里呢？\n\n![js-object-14](https://cdn.jsdelivr.net/gh/marsk6/image-center@master/js-object-14.png)\n\n每个数组都有一个单独的 `Elements`（_elements backing_）存储所有数组索引的属性值。JavaScript 引擎不必为每个索引存储属性特性，因为它们通常都是可写、可枚举和可配置的。\n\n![js-object-15](https://cdn.jsdelivr.net/gh/marsk6/image-center@master/js-object-15.png)\n\n但是，如果更改数组索引的属性特性怎么办？\n\n```js\n// Please don’t ever do this!\nconst array = Object.defineProperty([], '0', {\n  value: 'Oh noes!!1',\n  writable: false,\n  enumerable: false,\n  configurable: false,\n})\n```\n\n上面的代码片段定义了一个名为 `0` 的属性（恰好是一个数组索引），并修改了属性特性。在这种边缘情况下，JavaScript 引擎将整个 `Elements` 存储字典。\n\n![js-object-16](https://cdn.jsdelivr.net/gh/marsk6/image-center@master/js-object-16.png)\n\n即使只有一个数组元素具有非默认属性，整个数组的 `Elements` 也会进入这种缓慢且低效的模式。避免在数组索引上使用 `Object.defineProperty`！\n\n### 总结\n\n我们了解了 JavaScript 引擎如何存储对象和数组，以及形状和 ICs 如何帮助优化它们的常见操作。基于这些知识，我们确定了一些有助于提高性能的实用 JavaScript 编码技巧：\n\n- 总是以相同的方式初始化你的对象，所以它们不会有不同的 `shape`。\n- 不要乱用数组元素的 property 属性，这样可以高效地存储和操作它们。\n","prevArticle":null,"nextArticle":null,"readingTime":"18","brief":"js 引擎编译流程的简单描述；js 引擎用 shape 和 inline cache 做性能优化，介绍 shape 和 inline cache","toc":"- [JavaScript 引擎编译流程](#javascript-%E5%BC%95%E6%93%8E%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B)\n  * [解释器/编译器的工作流程](#%E8%A7%A3%E9%87%8A%E5%99%A8%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B)\n- [JavaScript Object Model](#javascript-object-model)\n- [优化属性访问](#%E4%BC%98%E5%8C%96%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE)\n  * [Shapes](#shapes)\n  * [shape 的转变链和 trees](#shape-%E7%9A%84%E8%BD%AC%E5%8F%98%E9%93%BE%E5%92%8C-trees)\n  * [Inline Caches (ICs)](#inline-caches-ics)\n  * [有效存储数组](#%E6%9C%89%E6%95%88%E5%AD%98%E5%82%A8%E6%95%B0%E7%BB%84)\n  * [总结](#%E6%80%BB%E7%BB%93)"},"relatedTags":[{"__typename":"Tag","name":"翻译文章","posts":[{"__typename":"Post","slug":"zh-cn-js-engine-shape-inline-cache"}]},{"__typename":"Tag","name":"性能优化","posts":[{"__typename":"Post","slug":"zh-cn-js-engine-shape-inline-cache"},{"__typename":"Post","slug":"if-disable-source-maps-in-live"}]}]},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"zh-cn-js-engine-shape-inline-cache"},"buildId":"TD84s2Xo2UN8FejtQxb1E","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>