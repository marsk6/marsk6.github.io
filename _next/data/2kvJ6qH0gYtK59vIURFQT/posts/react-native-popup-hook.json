{"pageProps":{"post":{"__typename":"Post","slug":"react-native-popup-hook","title":"react native 弹窗浮层的管理方式","tags":[{"__typename":"Tag","name":"react"}],"category":null,"ctime":1683803880000,"mtime":1683879240000,"date":"05-11","content":"\n## 背景\n\n在 react native 需求开发中，经常遇到浮层的需求，即 `Dialog`，`BottomDrawer`，`Modal` 等浮层组件，但内部的公共组件库总是难以满足需求，例如浮层层叠，操作浮层的方式，获取操作的结果等，需要二次开发。\n\n### 现有浮层实现相似点\n\n研究下了内部组件库的实现，实现上有相同，都有相似的展示浮层，关闭浮层的状态管理逻辑，\n\n```tsx title={Dialog.tsx} *{2,16}\nexport class Dialog extends PureComponent {\n  static showPopup = (config) => { // 👈🏻 操作显示浮层\n    return new Promise((resolve) => {\n      const inst = Dialog.instances[pageId];\n      if (inst) {\n        inst.setState({\n          show: true,\n          config,\n        });\n      }\n    });\n  };\n\n  handleDismiss = (result) => {\n    // 👇🏻 隐藏浮层\n    this.setState({ show: false }, () => this.resolve?.({ action: result }));\n  };\n\n  render() {\n    const { show } = this.state;\n    if (!show) {\n      return null;\n    }\n    return (\n      <View>\n        <TouchableOpacity onPress={() => this.handleDismiss(Dialog.Action.Cancel)}>\n          <Text>Cancel</Text>\n        </TouchableOpacity>\n      </View>\n    );\n  }\n}\n```\n\n### 现有浮层实现不同点\n\n使用上又有些不同，`Dialog` 渲染的位置会放在顶层组件树，然后在子组件内部通过 `Dialog.showPopup(config)` 配置并显示 `Dialog`\n\n```tsx title={Screen.tsx} *{7}\nfunction Screen() {\n  return (\n    <View>\n      <View>\n        <Child />\n      </View>\n      <Dialog /> {/* 👈🏻 在这里渲染 Dialog */}\n    </View>\n  );\n}\n```\n\n```tsx title={Child.tsx} *{3}\nfunction Child() {\n  const handlePress = () => {\n    const result = await Dialog.showPopup(config); // 👈🏻 配置并显示 Dialog，获取操作 Dialog 的结果\n  };\n  return <View onPress={handlePress}>{/* ... */}</View>;\n}\n```\n\n`BottomDrawer`，`Modal` 放到组件树，当普通组件引用，其实为了覆盖整个屏幕，也必须放在页面的顶层组件树中\n\n这个方式每个页面都要维护一套展示和隐藏的状态逻辑\n\n```tsx title={Screen.tsx} *{7-9}\nfunction Screen() {\n  return (\n    <View>\n      <View>\n        <Child />\n      </View>\n      <BottomDrawer show={state.showContent1}>{/* content */}</BottomDrawer>\n      <BottomDrawer show={state.showContent2}>{/* content */}</BottomDrawer>\n      <Modal visible={state.visible}>{/* content */}</Modal>\n    </View>\n  );\n}\n```\n\n### 存在问题\n\n这样维护起来有些混乱，每次需求开发都要把组件二次改造一下，要么页面存在大量展示隐藏的状态逻辑，使用方式也不一致，多次迭代后就得花更多时间学习研究组件怎么用，要么新的开发者又重新写一套。\n\n实际打开浮层，层叠展示多个浮层，关闭浮层，它们的状态管理逻辑基本一样，只是在表现层不一样，因此可以自定义一个 hook，提取它们的共同逻辑。\n\n## 代码实现\n\n用方法的形式操作浮层，提供 `open`，`close`，`closeAll` 3 个方法\n\n```typescript title={usePopupStack.ts}\nimport { ReactNode, useContext, useEffect, useMemo, useRef } from 'react';\nimport { Keyboard, Platform, BackHandler } from 'react-native';\nimport useCallbackState from './useCallbackState';\n\ntype TPopUpInfo = {\n  shouldShow: boolean;\n  component: ReactNode;\n  onClose: () => void;\n};\n\nexport type TManageStack = {\n  open: (renderComponent: (onClose: () => void) => ReactNode) => number;\n  close: (popUpId: number) => void;\n  closeAll: () => void;\n};\n\n/**\n * Dialog, BottomDrawer, Modal etc.\n */\nexport const usePopupStack = () => {\n  const [list, setList] = useCallbackState<TPopUpInfo[]>([]);\n  const popUpMap = useRef<Map<number, TPopUpInfo>>(new Map());\n  const manageStack = useMemo((): TManageStack => {\n    return {\n      open: (renderComponent) => {\n        const popUpId = Date.now();\n        const onClose = () => {\n          // 快速点击会执行多次\n          if (popUpMap.current.get(popUpId)) {\n            popUpMap.current.get(popUpId)!.shouldShow = false;\n            setList(cloneList(popUpMap.current), () => {\n              popUpMap.current.delete(popUpId);\n            });\n          }\n        };\n        const component = renderComponent(onClose);\n        popUpMap.current.set(popUpId, {\n          shouldShow: true,\n          component,\n          onClose,\n        });\n        Keyboard.dismiss();\n        setList(cloneList(popUpMap.current)); // 👈🏻 不能渲染 ref，把 list clone 存到 state 上\n        return popUpId;\n      },\n      close: (popUpId: number) => {\n        popUpMap.current.get(popUpId)?.onClose();\n      },\n      closeAll: () => {\n        [...popUpMap.current.values()].forEach((popup) => {\n          popup.onClose();\n        });\n      },\n    };\n  }, [setList]);\n\n  useEffect(() => {\n    // 监听 android 的实体返回键，关闭 pop up\n    if (Platform.OS === 'android') {\n      BackHandler.addEventListener('hardwareBackPress', function () {\n        if (popUpMap.current) {\n          const topPopupId = Array.from(popUpMap.current.keys()).pop();\n          if (topPopupId) {\n            manageStack.close(topPopupId);\n          }\n        }\n      });\n    }\n    return () => {\n      if (Platform.OS === 'android') {\n        BackHandler.removeEventListener('hardwareBackPress');\n      }\n    };\n  }, [manageStack]);\n\n  return { manageStack, list };\n};\n```\n\n### 用法\n\n每种浮层都用 `usePopupStack` 管理，用 context 往下传递 `open`，`close`，`closeAll` 3 个方法\n\n```tsx title={BottomDrawerContextProvider.tsx}\nimport React, { createContext, PropsWithChildren } from 'react';\nimport BottomDrawer from '//ButtomDrawer';\nimport { usePopupStack } from './usePopupStack';\nimport type { TManageStack } from './usePopupStack';\n\nexport const BottomDrawerContext = createContext({} as TManageStack);\n\nexport const BottomDrawerContextProvider: React.FC<PropsWithChildren> = (props) => {\n  const { manageStack: bottomDrawer, list: drawerList } = usePopupStack();\n\n  return (\n    <BottomDrawerContext.Provider value={bottomDrawer}>\n      {props.children}\n      {drawerList.map(\n        // 渲染 open 的 BottomDrawer\n        ({ component, shouldShow, onClose }, index) => (\n          <BottomDrawer\n            key={index}\n            shouldShow={shouldShow}\n            onDismiss={onClose}\n          >\n            {component}\n          </BottomDrawer>\n        )\n      )}\n    </BottomDrawerContext.Provider>\n  );\n};\n```\n\n浮层组件都放到顶层组件树渲染，这样浮层可以覆盖整个页面。\n\n```tsx title={Screen.tsx}\nfunction Screen() {\n  <BottomDrawerContextProvider>\n    <DialogContextProvider>\n      <View>...</View>\n    </DialogContextProvider>\n  </BottomDrawerContextProvider>;\n}\n```\n\n子组件从 context 获取 `open`，`close`，`closeAll` 方法\n\n```tsx title={Child.tsx}\nfunction Child() {\n  const bottomDrawer = useContext(BottomDrawerContext);\n  const handle = () => {\n    const drawerId = bottomDrawer.open((onClose) => {\n      return (\n        <View>\n          <Button onPress={onClose}>Close</Button>\n        </View>\n      );\n    });\n  };\n\n  useEffect(() => {\n    return () => {\n      bottomDrawer.close(drawerId);\n    };\n  }, []);\n\n  return <></>;\n}\n```\n\n这样，抽取一个 hook，每个组件不用维护浮层的状态，使用也简洁清晰。\n\n> [本博客](https://marsk6.github.io/) 所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！\n","prevArticle":{"__typename":"Post","title":"react hooks setState 支持 callback","slug":"setState-callback-react-hooks"},"nextArticle":null,"readingTime":"5","brief":"Dialog，BottomDrawer，Modal，Tooltip 等各种浮层弹窗虽然在表现上不一样，但他们的状态管理逻辑，如打开浮层，关闭浮层，层叠浮层等逻辑相差不大，因此可以实现一个 hook，抽取共同的逻辑，子组件间用 context 共享公共的浮层操作方法。","toc":"- [背景](#%E8%83%8C%E6%99%AF)\n  * [现有浮层实现相似点](#%E7%8E%B0%E6%9C%89%E6%B5%AE%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%9B%B8%E4%BC%BC%E7%82%B9)\n  * [现有浮层实现不同点](#%E7%8E%B0%E6%9C%89%E6%B5%AE%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%90%8C%E7%82%B9)\n  * [存在问题](#%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98)\n- [代码实现](#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0)\n  * [用法](#%E7%94%A8%E6%B3%95)"},"relatedTags":[{"__typename":"Tag","name":"react","posts":[{"__typename":"Post","slug":"error-boundary-for-custom-error"},{"__typename":"Post","slug":"react-native-popup-hook"}]}]},"__N_SSG":true}