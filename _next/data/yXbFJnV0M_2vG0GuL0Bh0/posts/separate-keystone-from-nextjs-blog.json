{"pageProps":{"post":{"__typename":"Post","slug":"separate-keystone-from-nextjs-blog","title":"CMS 和 Nextjs 博客分离部署","tags":[{"__typename":"Tag","name":"技术方案"}],"category":null,"ctime":1615731060000,"mtime":1652140800000,"date":"03-14","content":"\n## 前言\n\n前文讲了我的静态博客集成 keystone 来管理文章内容，所有内容（前端，CMS，文章数据库）都在同一个仓库。\n\n但这样对部署和更新文章很不友好，存在频繁切换分支保存开发中的功能和新文章内容，不注意就会把测试的内容带到线上，过多回滚等问题。\n\n因此为了减少维护的成本，对仓库进行拆分，做前后端分离，通过 github action 全静态部署。\n\n## 拆分仓库\n\n两套代码是独立，没有相互依赖，都可以单独运行，单独部署。那分开后前端如何从 keystone 获取数据？\n\n之前用 keystone 的 context api，不用启动 http 服务器，但这种方式有问题 [Error: Your schema.prisma could not be found](https://www.prisma.io/docs/guides/other/troubleshooting-orm/help-articles/nextjs-prisma-client-monorepo)。\n\n无法使用 context api，那就用 keystone 的 http 接口。\n\n代码拆分为 `nextjs-blog` 和 `blog-admin`\n\n1. 在 `nextjs-blog` 中安装 `@apollo/client`\n\n```shell\nyarn add @apollo/client graphql\n```\n\n1. 初始化 `graphql` 客户端\n\n```js\nimport { ApolloClient, InMemoryCache, gql } from '@apollo/client';\n\nconst client = new ApolloClient({\n  uri: 'http://localhost:3000/api/graphql',\n  cache: new InMemoryCache(),\n  // Enable sending cookies over cross-origin requests\n  credentials: 'include',\n});\n```\n\n1. 使用 http 接口\n\n对照 `blog-admin` 下的 `schema.graphql`，把 context api 查询修改为 graphql api\n\n```js -{1-6} +{8-25}\nexport async function getAllTags() {\n  const tags = await query.Tag.findMany({\n    query: 'name posts { title slug }',\n  });\n  return tags;\n}\n\nexport async function getAllTags() {\n  const {\n    data: { tags },\n  } = await client.query({\n    query: gql`\n      query {\n        tags {\n          name\n          posts {\n            title\n            slug\n          }\n        }\n      }\n    `,\n  });\n  return tags;\n}\n```\n\n如果担心 gql 语句写错了，可以打开 `http://localhost:3000/api/graphql` 先验证下。\n\n## 修改部署配置\n\n我没把 keystone 部署到云服务器，打算在 `nextjs-blog` Github Actions 的 runner 中先启动 keystone，再构建生成博客。\n\n### 修改 blog-admin 部署配置\n\n1. 增加 keystone 服务器 health check\n\n添加 http 健康检查 `bin/check.sh`，用来检测 keystone http 服务器有没有启动成功。\n\n```shell\n#!/bin/sh\nCHECK_PORT=3000\n\necho \"[CHECK INFO] $(date '+%Y-%m-%d %H:%M:%S') check http service\"\n\nhttp_code=`curl -s --connect-timeout 2 -o /dev/null -w \"%{http_code}\" http://localhost:$CHECK_PORT`\n\nif [ $http_code == 200 ] || [ $http_code == 302 ]\nthen\n    echo \"[CHECK INFO] check success $http_code\"\n    exit 0\nelse\n    echo \"[CHECK ERROR] check error $http_code\"\n    exit 2\nfi\n```\n\n```json title=package.json +{2-5}\n  \"scripts\": {\n    \"keystone:build\": \"NODE_ENV=production keystone build\",\n    \"keystone:start\": \"NODE_ENV=production keystone start\",\n    \"deploy\": \"yarn keystone:build && yarn keystone:start\",\n    \"healthcheck\": \"bash ./bin/check.sh\",\n  },\n```\n\n1. 修改 github action 配置\n\n当博客数据有修改时，通过 `blog-admin` 的 GitHub Actions 触发 `nextjs-blog` 自动部署。\n\n```yaml\nname: GitHub Actions Build and Deploy\non:\n  push:\n    paths:\n      - app.db # 当 app.db 有变动时触发 action\npermissions:\n  contents: write\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Repository Dispatch\n        uses: peter-evans/repository-dispatch@v2 # 触发叫 repository_dispatch 的 webhook 事件\n        with:\n          token: ${{ secrets.ACCESS_TOKEN }}\n          repository: marsk6/marsk6.github.io\n          event-type: admin-update-event # 需要 dispatch 的事件类型\n```\n\n### 修改 nextjs-blog 部署配置\n\n先启动 keystone http 服务器，再执行 blog 构建。\n\n1. 修改 `nextjs-blog` 构建脚本\n\n创建 `build.ts`，先用 `child_process` 把 keystone 服务器跑起来，再执行 `yarn next:build`。\n\n```ts title={build.ts}\nimport execSh from 'exec-sh';\nlet count = 0;\n\n/**\n * 判断 keystone 是否启动成功\n */\nconst isAdminRun = () => {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => {\n      execSh('yarn healthcheck', { cwd: './admin' }, (err) => {\n        if (err) {\n          if (count === 5) {\n            reject(err);\n          } else {\n            count++;\n            resolve(isAdminRun());\n          }\n        }\n        resolve('');\n      });\n      clearTimeout(timer);\n    }, 2000);\n  });\n};\nconst main = async () => {\n  console.log('---------------- start admin ----------------');\n  // 启动 keystone 服务器\n  const childProcess = execSh('yarn keystone:start', { cwd: './admin' });\n\n  await isAdminRun();\n\n  console.log('---------------- to next deploy ----------------');\n\n  // 构建博客\n  await execSh.promise('yarn next:build');\n  console.log('---------------- finish build ----------------');\n  // 关闭 keystone 服务器\n  childProcess.kill();\n};\n\nmain();\n```\n\n![[separate-keystone-from-nextjs-blog.png|构建流程]]\n\n```json title={package.json} +{2}\n  \"scripts\": {\n    \"build\": \"ts-node --transpileOnly ./script/build.ts\",\n  }\n```\n\n1. 修改 github action 配置\n\n```yaml\nname: GitHub Actions Build and Deploy Demo\non:\n  push:\n    branches:\n      - master\n  repository_dispatch: # 监听 blog-admin 发出的 repository_dispatch 事件\n    types: [admin-update-event] # 监听 dispatch 的事件类型 admin-update-event\npermissions:\n  contents: write\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: checkout blog repo\n        uses: actions/checkout@v3 # 默认拉取当前的仓库，即 nextjs-blog\n      - name: checkout admin repo\n        uses: actions/checkout@v3\n        with:\n          repository: marsk6/blog-admin # 拉取 blog-admin 的仓库\n          path: admin # 放到 nextjs-blog/admin 的路径下\n      - name: cache admin\n        uses: actions/setup-node@v3\n        with:\n          cache: 'yarn'\n      - name: install blog deps\n        run: |\n          pwd\n          yarn\n      - name: install admin deps\n        run: |\n          yarn --cwd ./admin\n      - name: build admin # 构建 blog-admin\n        run: |\n          yarn --cwd ./admin keystone:build\n      - name: build blog # 执行启动 keystone http 服务器，构建 nextjs-blog 的脚本\n        run: |\n          yarn build\n      - name: deploy blog # 部署到 github-pages\n        uses: JamesIves/github-pages-deploy-action@v4\n        with:\n          folder: out\n          token: ${{ secrets.ACCESS_TOKEN }}\n```\n\n![[separate-keystone-from-nextjs-blog-1.png|blog github action 流程]]\n\n## 关联\n\n[Repositories - GitHub Docs](https://docs.github.com/en/rest/repos/repos?apiVersion=2022-11-28#create-a-repository-dispatch-event)\n\n> [本博客](https://marsk6.github.io/) 所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！\n","prevArticle":null,"nextArticle":null,"readingTime":"5","brief":"keystone 和 nextjs 博客所有内容（前端，CMS，文章数据库）都在同一个仓库，不好维护，需要拆分仓库，通过 github action 全静态部署，在博客的 github action runner 中先启动 keystone 服务器，再运行博客构建。","toc":"- [前言](#%E5%89%8D%E8%A8%80)\n- [拆分仓库](#%E6%8B%86%E5%88%86%E4%BB%93%E5%BA%93)\n- [修改部署配置](#%E4%BF%AE%E6%94%B9%E9%83%A8%E7%BD%B2%E9%85%8D%E7%BD%AE)\n  * [修改 blog-admin 部署配置](#%E4%BF%AE%E6%94%B9-blog-admin-%E9%83%A8%E7%BD%B2%E9%85%8D%E7%BD%AE)\n  * [修改 nextjs-blog 部署配置](#%E4%BF%AE%E6%94%B9-nextjs-blog-%E9%83%A8%E7%BD%B2%E9%85%8D%E7%BD%AE)\n- [关联](#%E5%85%B3%E8%81%94)"},"relatedTags":[{"__typename":"Tag","name":"技术方案","posts":[{"__typename":"Post","slug":"intersectionobserver-table-of-content"},{"__typename":"Post","slug":"build-blog-with-nextjs"},{"__typename":"Post","slug":"build-blog-with-headless-cms"},{"__typename":"Post","slug":"deploy-blog-to-github-pages"},{"__typename":"Post","slug":"separate-keystone-from-nextjs-blog"}]}]},"__N_SSG":true}