{"pageProps":{"post":{"__typename":"Post","slug":"intersectionobserver-table-of-content","title":"使用 IntersectionObserver 实现目录","tags":[{"__typename":"Tag","name":"技术方案"}],"category":null,"ctime":1619568000000,"date":"04-28","content":"\n## 介绍\n\n使用 Intersection Observer API 和 `scroll-padding` 实现一个文章目录，能自动跟随高亮目录标题，其中 scroll-padding 用在当点击目录时，使标题滚到合适的可视区域。\n\n## 现状\n\n`IntersectionObserver` 的 callback 执行时机：\n\n- target 元素在上边界离开和进入可视区域\n- target 元素在下边界离开和进入可视区域\n- 初始化或快速滚动时，多个 target 同时在可视区域\n- 非鼠标滚动交互造成的滚动\n- ……\n\n因此为了确定**什么时候**高亮**哪一个**目录标题，设定几个 case。\n\n## case 设计\n\n前提：把上边界作为基线，`threshold` 设为 1，root 是 `document`\n\n- case1: 向上滚动，到基线，变成不相交，active 当前标题\n- case2: 向下滚动，到基线，变成相交，active 上一个标题\n- case3: 初始化，`heading.getboundingClientRect().top` 离基线最近的 active 标题\n- case4: 点击目录，跳到 heading，直接 active，跳过 observe 处理\n- caseX: 其他不处理\n\n## 代码实现\n\n### 设置上边界和 `scroll-padding-top`\n\n```typescript\nconst baseLine = 156 // 上边界的基线位置\nconst distanceActionToCase1 = baseLine - 6 // scroll-padding-top，点击目录跳转后的标题位置视为 case1\nconst init = () => {\n  document.documentElement.style.scrollPaddingTop = `${distanceActionToCase1}px`\n}\n```\n\n![baseLine](https://cdn.jsdelivr.net/gh/marsk6/image-center@master/io-toc.png)\n\n用前后的 `scrollTop` 判断滚动方向\n\n```ts\nconst observer = new IntersectionObserver(\n  (entries) => {\n    let prevScollTop = document.documentElement.scrollTop\n    const isScrollDown = prevScollTop > document.documentElement.scrollTop\n    const isScrollUp = !isScrollDown\n    prevScollTop = document.documentElement.scrollTop\n    // ...\n  },\n  {\n    threshold: [1],\n    root: document,\n    rootMargin: `-${baseLine}px 0px 0px 0px`, // 设置 rootMargin\n  }\n)\n```\n\n### 处理 case3\n\n比较 `IntersectionObserverEntry.boundingClientRect.top` 和 `baseLine` 的距离，确定哪个 `heading` 离基线最近\n\n```ts\nconst observer = new IntersectionObserver(\n  (entries) => {\n    // ...\n    let willActiveHeading: Element | null = null\n    let isInit = true\n    entries.forEach((entry) => {\n      const { top } = entry.boundingClientRect\n      if (isInit) {\n        if (\n          Math.abs(top - baseLine) <=\n          Math.abs(initClosestHeading.boundingClientRect.top - baseLine)\n        ) {\n          initClosestHeading = entry\n        }\n        return\n      }\n      // ...\n    })\n    if (isInit) {\n      const { hash } = location\n      if (hash) {\n        ;(\n          document.querySelector(`.toc a[href='${hash}']`) as HTMLAnchorElement\n        ).click()\n      } else {\n        initClosestHeading.target.dispatchEvent(new CustomEvent('active'))\n      }\n      isInit = false\n    }\n  }\n  // ...\n)\n```\n\n### 处理 case1 和 case2\n\n```ts\nconst observer = new IntersectionObserver(\n  (entries) => {\n    // ...\n    let willActiveHeading: Element | null = null\n\n    entries.forEach((entry) => {\n      if (entry.isIntersecting && isScrollDown) {\n        willActiveHeading = entry.target\n      } else if (!entry.isIntersecting && isScrollUp) {\n        willActiveHeading = entry.target\n      }\n    })\n  }\n  // ...\n)\n```\n\n### 处理 case4\n\n在点击跳转过程中，依然会触发 observer 的 callback\n\n```ts\nconst article = document.querySelector('.markdown-body')\nconst allHeadings = article?.querySelectorAll('h1,h2,h3,h4')\nallHeadings?.forEach((heading, index) => {\n  let a = findToc(heading)\n  a?.addEventListener('click', () => {\n    tocJumpTo = heading\n    tocJumpTo.dispatchEvent(\n      new CustomEvent('active', {\n        detail: 'cur',\n      })\n    )\n    prevScollTop = document.documentElement.scrollTop\n  })\n  heading.addEventListener('active', (e) => {\n    toc.forEach((t) => t.classList.remove('active-heading'))\n    if ((e as CustomEvent).detail === 'prev' && index !== 0) {\n      const prevA = findToc(allHeadings[index - 1])\n      prevA?.classList.add('active-heading')\n      return\n    }\n    a?.classList.add('active-heading')\n  })\n  observer?.observe(heading)\n})\n```\n\n完整代码（React）\nhttps://github.com/marsk6/marsk6.github.io/blob/master/src/components/Toc.tsx\n\n## 实现效果\n\n![实现效果](https://cdn.jsdelivr.net/gh/marsk6/image-center@master/io-toc.gif)\n\n> 本博客 ([Hea的web博客](https://marsk6.github.io/)) 所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！\n","prevArticle":null,"nextArticle":null,"readingTime":"0","brief":"用 Intersection Observer API 实现文章目录，目录能跟随页面滚动而高亮标题","toc":"- [介绍](#%E4%BB%8B%E7%BB%8D)\n- [现状](#%E7%8E%B0%E7%8A%B6)\n- [case 设计](#case-%E8%AE%BE%E8%AE%A1)\n- [代码实现](#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0)\n  * [设置上边界和 `scroll-padding-top`](#%E8%AE%BE%E7%BD%AE%E4%B8%8A%E8%BE%B9%E7%95%8C%E5%92%8C-scroll-padding-top)\n  * [处理 case3](#%E5%A4%84%E7%90%86-case3)\n  * [处理 case1 和 case2](#%E5%A4%84%E7%90%86-case1-%E5%92%8C-case2)\n  * [处理 case4](#%E5%A4%84%E7%90%86-case4)\n- [实现效果](#%E5%AE%9E%E7%8E%B0%E6%95%88%E6%9E%9C)"},"relatedTags":[{"__typename":"Tag","name":"技术方案","posts":[{"__typename":"Post","slug":"intersectionobserver-table-of-content"},{"__typename":"Post","slug":"build-blog-with-nextjs"},{"__typename":"Post","slug":"build-blog-with-headless-cms"}]}]},"__N_SSG":true}